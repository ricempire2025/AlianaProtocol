# 资金健康监控自动调节系统 - 链上实施方案

本文档基于《健康监控自动调节系统》架构设计，详细定义链上合约接口、数据结构修改及核心逻辑实现路径。

---

## 1. 核心接口定义 (Interfaces)

我们将系统拆分为三个主要部分：
1.  **AlianaProtocol** (主业务合约)
2.  **HealthController** (决策与限流控制器)
3.  **ReserveVault** (独立准备金库)

### 1.1 IHealthController.sol

`HealthController` 负责维护健康状态（Mode）、动态参数（Params）以及执行限流检查。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IHealthController {
    // 健康模式枚举
    enum HealthMode {
        Normal,     // 0: 正常
        Watch,      // 1: 观察
        Throttle,   // 2: 限流
        Stabilize,  // 3: 稳态/去杠杆
        Emergency   // 4: 紧急
    }

    // 动态参数结构体
    struct DynamicParams {
        uint16 adminFeeBps;           // 管理费率 (基准 500 = 5%)
        uint16 reserveFeeBps;         // 准备金留存费率
        uint256 minWithdrawAmount;    // 最小提现额
    }

    // 事件
    event HealthModeChanged(HealthMode oldMode, HealthMode newMode, uint256 timestamp);
    event ParamsUpdated(bytes32 paramName, uint256 oldValue, uint256 newValue);
    event WithdrawThrottled(address indexed user, uint256 requested, uint256 allowed);

    // --- 视图函数 ---
    
    // 获取当前健康模式
    function getHealthMode() external view returns (HealthMode);

    // 获取当前生效的动态参数
    function getDynamicParams() external view returns (DynamicParams memory);

    // 检查提现额度（限流核心逻辑）
    // @param user: 提现用户
    // @param amount: 请求提现金额
    // @param isNetworkReward: 是否为网络收益（可能限流策略不同）
    // @return allowedAmount: 允许提现的金额
    // @return reason: 限流原因代码 (0=通过)
    function checkWithdrawLimit(address user, uint256 amount, bool isNetworkReward) 
        external 
        returns (uint256 allowedAmount, uint256 reason);

    // --- 权限/钩子函数 ---
    
    // 入金前置钩子 (用于统计流量或阻断)
    function beforeDeposit(address user, uint256 amount) external;

    // 复投前置钩子 (用于统计)
    function beforeCompound(address user, uint256 amount, bool isNetworkReward) external;
}
```

### 1.2 IReserveVault.sol

`ReserveVault` 作为独立的资金池，用于存储超额留存的手续费，并在紧急情况下提供流动性支持。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IReserveVault {
    event FundsReceived(address indexed sender, uint256 amount);
    event LiquidityReleased(address indexed recipient, uint256 amount, string reason);

    // 接收资金 (通常来自 AlianaProtocol 的 reserveFeeBps 部分)
    function depositToken(address token, uint256 amount) external;

    // 释放流动性 (仅限 Timelock 或 HealthController 在 Emergency 模式下调用)
    function releaseLiquidity(address recipient, uint256 amount, string calldata reason) external;
    
    // 获取当前储备金余额
    function getBalance(address token) external view returns (uint256);
}
```

---

## 2. AlianaProtocol 修改方案

主合约需要引入 `HealthController` 的引用，并在关键业务流程中插入 Hook。

### 2.1 状态变量新增

```solidity
    // 在 AlianaProtocol 中添加
    IHealthController public healthController;
    IReserveVault public reserveVault;
    
    // 是否启用健康控制的开关 (紧急熔断用)
    bool public useHealthController = true;

    modifier onlyHealthController() {
        require(msg.sender == address(healthController), "Not HealthController");
        _;
    }
```

### 2.2 关键业务 Hook 插入点

#### A. 入金 (makeDeposit)

**修改前逻辑**：
1. `USDT.transferFrom(user, this, amount)`
2. `USDT.transfer(treasury, amount * 5%)`
3. 记录 Deposit

**修改后逻辑**：
```solidity
function makeDeposit(uint256 amount, ...) external {
    // 1. Hook: 通知控制器，可能触发熔断或统计
    if (useHealthController) {
        healthController.beforeDeposit(msg.sender, amount);
    }
    
    // 2. 转入资金
    usdtToken.transferFrom(msg.sender, address(this), amount);

    // 3. 动态费率分配
    uint256 adminFee = 0;
    uint256 reserveFee = 0;
    
    if (useHealthController) {
        // 获取动态参数
        IHealthController.DynamicParams memory params = healthController.getDynamicParams();
        
        // 计算费用 (使用动态费率 params.adminFeeBps 和 params.reserveFeeBps)
        // 注意：需确保 params.adminFeeBps + params.reserveFeeBps <= 20% (硬顶保护)
        adminFee = amount * params.adminFeeBps / 10000;
        reserveFee = amount * params.reserveFeeBps / 10000;
    } else {
        // 降级回默认 5%
        adminFee = amount * 5 / 100;
    }

    // 4. 分发费用
    if (adminFee > 0) usdtToken.transfer(treasuryWallet, adminFee);
    if (reserveFee > 0) usdtToken.transfer(address(reserveVault), reserveFee);
    
    // ... 后续逻辑保持不变 ...
}
```

#### B. 提现 (claimDailyRewards / claimNetworkRewards)

这是核心限流点。

**修改后逻辑**：
```solidity
function claimDailyRewards() external nonReentrant {
    // 1. 基础检查
    // ...

    // 2. 计算原始可提现额
    uint256 totalClaimable = _calculateAndUpdatePendingRewards(msg.sender);
    require(totalClaimable > 0, "No rewards");

    // 3. Hook: 限流检查
    uint256 allowedAmount = totalClaimable;
    if (useHealthController) {
        // checkWithdrawLimit 会更新用户的每日提现额度使用情况
        (uint256 approved, uint256 reason) = healthController.checkWithdrawLimit(msg.sender, totalClaimable, false);
        
        if (approved < totalClaimable) {
            // 如果被限流，剩余部分保留在 pendingRewards (需修改 _calculateAndUpdatePendingRewards 逻辑支持部分提现)
            // 或者：简单做法是本次只能提 approved，剩下的还在累积
            allowedAmount = approved;
            emit WithdrawThrottled(msg.sender, totalClaimable, approved);
        }
        require(allowedAmount > 0, "Withdrawal limit reached");
        
        // 应用动态最小提现额
        IHealthController.DynamicParams memory params = healthController.getDynamicParams();
        require(allowedAmount >= params.minWithdrawAmount, "Below min withdraw");
    }

    // 4. 转账
    if (allowedAmount > 0) {
        // 如果是部分提现，需要把未提现的差额加回用户的 pendingRewards
        // 这里的逻辑需要仔细处理 storage 更新
        if (allowedAmount < totalClaimable) {
            users[msg.sender].pendingDailyRewards += (totalClaimable - allowedAmount);
        }
        
        usdtToken.transfer(msg.sender, allowedAmount);
        emit DailyRewardsClaimed(msg.sender, allowedAmount, block.timestamp);
    }
}
```

#### C. 复投 (compound...)

**修改后逻辑**：
复投入口保留 `beforeCompound` 钩子，主要用于风险期统计与观测（例如复投占比、复投金额分布），并作为未来扩展（如应急队列模式下允许更顺畅复投）预留接口。

---

## 3. HealthController 详细逻辑设计

### 3.1 状态机管理

```solidity
contract HealthController is IHealthController, Ownable {
    HealthMode public currentMode;
    
    // 状态机配置
    struct ModeConfig {
        uint256 maxDailyWithdrawPerUser; // 单用户单日上限
        uint256 maxGlobalWithdrawHourly; // 全局每小时上限
        uint256 cooldownSeconds;         // 提现冷却
        uint16 baseFeeBps;               // 基础管理费
        // ... 其他参数配置
    }
    
    mapping(HealthMode => ModeConfig) public modeConfigs;
    
    // 用户限流记录
    mapping(address => uint256) public userDailyWithdrawAmount;
    mapping(address => uint256) public userLastWithdrawTime;
    
    // 全局限流记录
    uint256 public globalHourlyWithdrawAmount;
    uint256 public currentHourTimestamp;

    // 切换模式 (仅 Owner 或 Timelock 或 Keeper 经逻辑验证后调用)
    function setHealthMode(HealthMode _mode) external onlyOwner {
        // 可以在这里加入 降级冷却(Hysteresis) 逻辑
        emit HealthModeChanged(currentMode, _mode, block.timestamp);
        currentMode = _mode;
    }
}
```

### 3.2 限流算法实现 (checkWithdrawLimit)

```solidity
function checkWithdrawLimit(address user, uint256 amount, bool isNetworkReward) 
    external 
    override 
    onlyProtocol 
    returns (uint256 allowed, uint256 reason) 
{
    ModeConfig memory config = modeConfigs[currentMode];
    
    // 1. 冷却检查
    if (block.timestamp < userLastWithdrawTime[user] + config.cooldownSeconds) {
        return (0, 1); // Cooling down
    }

    // 2. 单用户每日上限检查 (需结合 block.timestamp / 1 days 重置逻辑)
    // 这里简化写，实际需要 epoch 逻辑
    uint256 userUsed = _getUserDailyUsage(user); 
    if (userUsed + amount > config.maxDailyWithdrawPerUser) {
        amount = config.maxDailyWithdrawPerUser - userUsed;
        if (amount == 0) return (0, 2); // Daily limit reached
    }

    // 3. 全局每小时上限检查
    _updateGlobalHourlyUsage();
    if (globalHourlyWithdrawAmount + amount > config.maxGlobalWithdrawHourly) {
        amount = config.maxGlobalWithdrawHourly - globalHourlyWithdrawAmount;
        if (amount == 0) return (0, 3); // Global hourly limit reached
    }

    // 4. 记录使用量
    _recordUsage(user, amount);
    
    return (amount, 0);
}
```

---

## 4. 实施步骤建议

1.  **准备阶段**：
    *   部署 `ReserveVault`。
    *   部署 `HealthController` 并配置初始参数（Normal 模式）。
2.  **协议升级阶段**：
    *   修改 `AlianaProtocol`，加入 `healthController` 变量、Hook 逻辑。
3.  **参数配置阶段**：
    *   设置 `Throttle` 模式的限流阈值（例如：单人每日 2000 USDT，全局每小时 50000 USDT）。
    *   设置 `Stabilize` 模式的费率（例如：管理费 10%）。
4.  **权限移交**：
    *   将 `HealthController` 的 Owner 设置为 Timelock 合约。
    *   配置 Keeper 地址用于自动触发模式切换（如果采用 Hybrid 模式）。

此方案实现了业务逻辑与风控逻辑的解耦，最大程度降低了对主合约的侵入性，同时提供了强大的动态调节能力。
